Proposal for Orbital 24



Project Information	3
Project Overview	5
Motivation	5
Aim	5
Tech Stack	5
User Stories	6
Proposed Project	7
Proposed Features	7
Proposed Timeline	8
Software Engineering	9
Gameflow	11
Design Concept	12
Implemented Features	13
Characters	13
Types of Characters	13
Health	13
Movements	14
Attack	14
Enemies and Obstacles	15
Types of Enemies and Obstacles	15
Health	15
Movement	15
Damage	16
Camera Movements	17
UI	18
Health UI	18
Score UI	19
Pause Menu	20
Main Menu	21
Game Session & Scene Persist	23
Health System	24
Take Damage	24
Add Health	24
Score System	25
Collectibles	25
High Score System	26
Save Game System	27
Save Collectible ID	27
Save Enemy ID and Position	29
Save Player position	30
Save Score	30
Save Health	30
Save CurrentScene	30
Load Game System	31
Limited Player Vision	33
Level Advance	34
Enemy Boss	35
Animation	37
Boss Character and Health Bar Sprites	38
Problems Encountered	40
User Feedback	42
System Testing	44
Unit Testing	45
Credits	47

Project Information


Team Name: 
Cosmic Conquest

Team ID:
6237

Team Members:
Nicholas Chong Xian He
Tan Zhe Hui

Proposed Level of Achievement: 
Apollo 11

Code Base:

Link to repository:
https://github.com/ae-24/Orbital-24 

Link to hardware and code documentation:
https://github.com/ae-24/Orbital-24/tree/main/Cosmic%20Conquest

Technical Test:

To Play Technical Test:
Go to Cosmic Conquest Milestone 3 
Download the all files in the folder
Open the Application
Alt-Tab to close the Application

Qualifications:

Our team consists of two students enrolled in Computer Engineering with prior experiences such as CS1010. 

Languages learnt: Python, C, C++

Milestones:

Project Pitch (Liftoff):

Pitch Poster:
6237.png 

Pitch Video:
6237.mp4 


Milestone 1: 

Milestone 1 Poster:
6237.png

Milestone 1 Video:
6237.mp4

Core Features to be implemented in Milestone 2:
Health UI
Score System
Coins Collectible (for score system)
Pause Menu System
Main Menu

Milestone 2:

Milestone 2 Poster:
6237.png

Milestone 2 Video:
6237.mp4 

Core Features to be implemented in Milestone 3:
Limited Player Vision
Health Pickup
High Score System
Save Game System
Dual-Phase Boss Fight

Milestone 3:

Milestone 3 Poster:
6237.png

Milestone 3 Video:
6237.mp4 

Project Log:
Cosmic Conquest Project Log 


Project Overview
Motivation 

University life can often be accompanied by stress and mental fatigue. During these stressful periods, it is essential to find moments of respite that can not only alleviate mental tensions but can also improve cognitive well-being. We are also interested in game development and would like to use this opportunity to step into the world of game design. We hope to be able to expand upon our creativity and levy our skills to produce a game we can call our own.

Aim 

We hope to reduce the stress that students will have from their studies, allowing them to improve their mental wellness. We hope to develop a combat-oriented 2D platformer, which tests the skills and reflexes of the player, to both de-stress and improve upon their hand-eye coordination. While there are already many similar games out there, we aim to improve upon their positive aspects, by introducing unique mechanics and exciting gameplay. Furthermore, we aim to engage the audience with an interesting art style.

Tech Stack

Unity
C#
Github
Aseprite

User Stories

As a stressful student, I want to be able to immerse myself in a fun and engaging combat game, so that I can distress.
As a student who wants to try out a different method of relieving stress, I want to be able to try out a game with a cool art style, so that I can be engaged in the unique and interesting game.
As a person with few hobbies, I want to try out a different variation of games, so that I can find a new hobby to engage myself in.
As someone who likes challenges, I want to be able to experience completing a challenging game, so that I can feel accomplished.

Proposed Project
Proposed Features

Feature 1 (core): Interactable objects in the world (E.g level exit portals, hazards etc.)
Feature 2 (core): Player Health and Score System 
Feature 3 (core): Multiple Characters System (E.g Different characters who use different weapons: Sword, Axe, Bow etc.)
Feature 4 (core) : Save Game System
Feature 5 (extension): High Score System
Feature 6 (extension): Limited Player Vision (FOV of player will be limited)
Feature 7 (extension): Health Pickups
Feature 8 (extension): Dual-Phase Boss Fight (Boss will change difficulty after certain conditions are met)


Proposed Timeline

Milestone 1 - Technical proof of concept (i.e., a minimal working system with both the frontend and the backend integrated for a very simple feature)
Feature 1 (Interactable objects) implemented to skeleton level.

Milestone 2 - Prototype (i.e., a working system with the core features)
Feature 2 (Health and Score IU) 	Player Health and Score System
Feature 3 (Multiple Characters System) implemented to basic functionality.

Milestone 3 - Extended system (i.e., a  working system with both the core + extension features)
Feature 4 (Save Game System) implemented to basic functionality.
Feature 5 (High Score System) implemented to the desired level.
Feature 6 (Limited Player Vision) implemented to the desired level.
Feature 7 (Health Pickups) implemented to the desired level.
Feature 8 (Dual-Phase Boss Fight) implemented to basic functionality.

Software Engineering

User Experience (UX) Design: We will be incorporating UX design to create intuitive and engaging player experiences. We will utilize user testing, and iterative design cycles to refine our game mechanics, interfaces, and interactions to meet player expectations and preferences.
User Testing: Conduct regular testing sessions with players to gather feedback on game mechanics, interfaces, and interactions. This helps identify pain points and areas for improvement.
Iterative Design Cycles: Utilize an iterative design process where design improvements are continuously made based on user feedback. This allows for the refinement of features and ensures that the game evolves to meet player preferences.
Engaging Interfaces: Focus on creating visually appealing and user-friendly interfaces that enhance the overall gaming experience.

Incremental Development: We will ensure that the game features and content are developed incrementally, with each iteration building upon the work of previous iterations. This allows us to prioritize and deliver key features.
Iterative Development: Break down the game development into smaller, manageable increments. Each iteration focuses on adding specific features or enhancements.
Prioritization: Prioritize key features and ensure they are developed and tested thoroughly before moving on to the next iteration.
Continuous Integration: Regularly integrate new features into the main game build to maintain a cohesive and up-to-date version.

Community Feedback and Engagement: We will actively engage with the game community and collect feedback from players. We will also incorporate these player-driven suggestions and insights into the development process to enhance the enjoyment of the game.
Feedback Collection: Use forums and surveys, to gather player feedback and suggestions.
Link to form: https://forms.gle/GgPWD6bmSXiksVbW7 

Community Engagement: Engage with players through regular updates, responding to their feedback, and involving them in the development process.
Player-Driven Improvements: Analyze feedback and incorporate player-driven suggestions to enhance game enjoyment and meet player expectations.


Version Control: Using tools for version control such as Github enables us to revert any changes that cause issues or conflicts. We can also use this to ensure that there is always a safe point to back up while trying out new concepts and ideas, allowing us to innovate safely.
Version Control Systems: Utilize tools like GitHub to manage code repositories, track changes, and collaborate effectively with the development team.
Safe Points: Create regular backup points to revert to in case of issues or conflicts, ensuring that new concepts and ideas can be tested safely.
Change Management: Document and track all changes to maintain a clear history of the development process.
Gameflow

The flowchart below shows a brief overview of how our game flows when the user interacts with certain functions. 

Cosmic Conquest Gameflow

When the game starts, the user can only clear the stage by reaching the exit sign. When the player dies, he will be teleported back to the designated starting position of the same level. Their lives will be decreased by one. When the player dies for the third time and uses up all their lives, they will be teleported back to the starting position of the previous level. The player will need to clear that stage before advancing to the subsequent levels.

Design Concept

The following is a simple design process for creating Cosmic Conquest. Each stage is not mutually exclusive and we will always review previous stages for adequacy. 

Game Design Process

For our design decisions, we prioritise meeting the objectives of our project, while ensuring the user interface and user experience aspects are met. Hence, we take the feedback of our user testing seriously and make the necessary changes if we deem this feedback valid.
We aim to make the game stress-free and easy to play while maintaining a slight competitiveness value to it. For example, for each game session, the player has three lives to play the game comfortably.

Implemented Features
Characters
Types of Characters
There are a total of three characters implemented in Cosmic Conquest. Two of our characters are self-designed to enhance our game’s uniqueness and stylish concept. The characters’ design are as follows.








   Default Character			Archer			     Warrior
Health
By default, all the characters start the game with three lives. When it collides with an obstacle or enemy, the ProcessPlayerDeath() function will trigger, decreasing its’ health by one. The character will then be reset to the current scene at the designated starting position. This will continue until it has used up all of its lives, resetting the game.

Movements
Using the popular WASD keys for movement, we have bound the following keys to manoeuvre around the game.

W - Climb Up / Jump
A - Move Left
S - Climb Down
D - Move Right
Spacebar - Jump
Left Click - Shoot
Esc - Pause Game

Attack
Default: Range character, shoots a bullet when the shoot button is pressed. Deals one damage.
Archer: Range character, shoots a projectile arrow when the shoot button is pressed. Deals one damage.
Mage: Melee character, attacks with a short ranged sword. Deals three damage.

Design Process:
We initially wanted the game to be of a single character that uses melee attacks. After researching the various 2D platform games available online, we realised that the game would be much more interesting and fun to play if we were to add more characters with different abilities into the game. This allows for more variety of controls and visuals for the user and gives them a greater sense of satisfaction from playing the game.


Enemies and Obstacles
Types of Enemies and Obstacles
We have implemented an enemy and obstacle to increase our game’s difficulty. These enemies are scattered all over the map. The user has to attack these enemies to destroy them and dodge these obstacles. When collided, they will be damaged.








Enemy 1					Spikes (Obstacles)
Health
Each enemy has three health. When attacked by the characters, its health will deplete according to the damage dealt to them. Once all three health has depleted, the enemy will be destroyed. This is done using the TakeDamage() function that will be called when the weapon collides with the enemy.

Movement
The enemies are designed to be mobile to ensure complexity of the game. It moves in one direction initially. When it collides with the wall, it will flip direction and move in the opposite direction. This is done using OnTriggerExit() function that checks when there is a wall infront of the enemy.

Damage
When the enemy collides with the characters, they will deal damage equivalent to one live of the character.

Design Process:
The game was initially set to be just with movable enemies which the user has to attack to destroy them. Through thorough research on available games online, we found that having obstacles brings about more variety in the game as they are not able to attack them, but rather have to master the controls of the characters to dodge these obstacles. This provides a fresh challenge for them.



Camera Movements

The camera will follow the player to ensure a more realistic POV. The movements are smooth and zoom in and out depending on the character’s speed, which allows for a better User Experience.


We use a state-driven camera, which follows the character depending on what actions it is performing. The field of view also changes based on whether the character is stationary or in motion.
UI
Health UI
We have implemented Health UI at the top left of the game screen. This gives an indicator of how much lives the player has left. Empty life is indicated as , while a full life is indicated as . 






Full Lives					        Two lives remaining

Our Health UI are added as images to the game screen, and it is updated using the following code. The code checks for the value of the variable playerLives and updates the images of the health accordingly.

Design Process:
We chose a discrete health bar system instead of a continuous one to give the user a clearer idea of how many lives they are left with. We added empty hearts to indicate the maximum number of lives the user can have. These designs provide for a better user experience.
Score UI
We have implemented Score UI at the top right of the game screen. This score UI indicates the amount of score the user have accumulated throughout the game. After all three lives are used up, the score will reset to zero.

    Zero Score				     	       Score of 400
This is done by adding a score text on the game screen, and writing the score variable to this score text whenever AddToScore() function is called.


Design Process:
By implemented a Score UI, it allows the user to see updated score of his current game session. This enhances user experience as they are able to see his progress throughout the game.
Pause Menu
The Pause / Resume system allows the player to pause their progress and resume playing at the appropriate time. To pause the game, the player can either press the pause button at the bottom left corner of the game screen or press the ‘Esc’ key. 
This brings up a pause menu where the player can choose various options like resuming the game, going back to the main menu or quitting the game.


Game paused

This feature is implemented using the panel feature under UI. Whenever the ‘Esc’ key or pause button is pressed, the pause panel will be activated by setting it to be active.
Each button works using the On Click function, which references its respective function in the script.
 


Main Menu
We have implemented a main menu scene for the game. The main menu will be displayed when the user enters the game or when the user presses the main menu option during the game. There are four interactive buttons; start the game, view their stats, quit the game or reset their high score.

Main Menu Scene
When the play button is pressed, a separate panel is set active which allows the user to choose to start a new game or continue the previous game using saved data which will be explained in later parts of this report. The user can also close this panel by clicking on the close button.

Play Panel
When the stats button is pressed, a separate panel is set active which allows the user to view his high score. High score system will be explained in later parts of this report. The user can then close this panel by clicking on the close button.

Stats Panel

On the other hand, clicking on the quit button closes the game, and clicking on the reset score button resets the high score to zero. Similar to the pause menu, these buttons uses On Click function to call its respective functions.

Main Menu Script

Design Process:
We decided to add a main menu to allow for a more comprehensive gameplay. The user can decide when to start instead of having to abruptly play the game once they open the application.
Game Session & Scene Persist

The game session and scene persist work to keep track of player lives and score, as well as pickups and enemies respectively. Both of these game objects function similarly, using a singleton, to ensure that while the player has more than 1 life, the current game session or scene persist is kept, and that it is the only existing game object of that type. This ensures that throughout the 3 lives of the player, their health, score items picked up and enemies killed are kept track of and accurately represented.

Scene Persist Script

Health System

As explained, the game session initiates with PlayerLives = 3. When all three lives are used up, the game session will reset and the user will load to the previous scene at its designated starting position.
Take Damage
When the character takes damage, the TakeLife() function will be called and it will decrement the PlayerLives by one, while resetting the character’s position.

TakeLife() function
Add Health
We have implemented health pickup feature to give the user the opportunity to complete the game despite losing lives throughout the game. When the health pickup is collected, AddHealth() function will be called, incrementing the PlayerLives by one. This health pickup will then be set to inactive to prevent the user from collecting it again.

Health Pickup

AddHealth() function
Score System

As mentioned, we have incorporated a score UI at the top right of the screen. We implemented a scoring system to give this game a competitive aspect while ensuring it does not get too stressful to play.
Collectibles
To increase your score, the user will have to collect the collectibles available in the form of a coin. The coin is collected using the OnTriggerEnter2D() function, which then calls the Collect() function and AddToScore() function as mentioned earlier. This sets the coin to inactive which ensures the user cannot collect the coin again. We have also added SFX when the coins are collected to improve the User Experience. The score registered to each coin also defers depending on its size.

Score before collecting coins 			Score after collecting coins

OnTriggerEnter2D() function
High Score System
We have also implemented a high score system which tracks the highest score the user have accumulated thus far. This is done using PlayerPrefs, which stores the high score value. 
When the game session is resetted, CheckHighScore() function will be called, which checks whether the score for that session is higher than the high score. If so, high score value will be updated and saved into PlayerPrefs. This high score will then be written to the high score text in the stats panel.
When the reset high score button is pressed, ResetHighScore() function will be called which resets the high score value to zero and write this high score value to the high score text.

CheckHighScore() function

OnTriggerEnter2D() function

OnTriggerEnter2D() function
Save Game System
Save Collectible ID
To ensure each collectible’s data is saved, we have assigned each collectible a unique ID. This ID is generated using UnityEditor. To simplify this ID generation process, we have also included a script that loops through the function for each collectible available. The ID will then be generated with a simple click of a button.

ID Generator function

AssignUniqueIDs() function
When the collectible is collected, the Collect() function sets that specific collectible ID to a value of 1 using PlayerPrefs. When the game continues from the main menu, the script will then check each collectible, setting those collectible ID of value 1 to inactive to prevent the user from collecting the same collectible twice.

Collect() function
We have also included CollectibleManager script which registers and resets all the collectibles available. This allows the PlayerPrefs of each registered collectible to be deleted when necessary.

CollectibleManager script

Save Enemy ID and Position
Similar to the way the game enquire the state of each collectible, we have implemented PlayerPrefs to be set to 0 for each enemy ID whenever the Die() function is called. When continue game is activated, checks will be done on the value registered to each enemy ID, preventing the enemy from spawning after it is dead.

Die() function
Other than saving the state of each enemy, we have also implemented the position of each enemy to be saved. This is also done using PlayerPrefs, where the X, Y position of each enemy is saved using transform position. The position of each enemy loads by retrieving these values from respective enemy and spawning them at these position.

Die() function
Save Player position
The Character’s position is also saved and loaded using the same logic as the enemy’s. The X and Y position of the character is retrieved using transform position and saved in PlayerPrefs. When the game loads, player position will be set to these values. 

Save and Load Player Position
Save Score
The game’s score is easily saved using PlayerPrefs by first retrieving the value of the score from game session and writing this value to the ScoreValue key under PlayerPrefs.
Save Health
Similar to the saving of score, the value of PlayerLives is retrieved from game session and writing this value to the PlayerLives key under PlayerPrefs.
Save CurrentScene
The value of current scene is retrieved from SceneManager and writing this value to the SavedScene key under PlayerPrefs.

Load Game System

After all the data on the game is saved, these information will be used to load the game when the continue button is pressed. To check if there are data saved, we have added the key playerStarted under PlayerPrefs when main menu button is clicked on. The script will check for the presence of this key to determine if the game can be continued. We used IEnumerator to ensure the game session has loaded completely before the scene is loaded in, preventing any possible errors from occuring.
The relevant data such as score and player lives will then be overwritten in game session from PlayerPrefs. The player’s and enemies’ position will then be loaded in.

Continue Game code
Limited Player Vision
We have implemented limited field of view for the user to enhance the game style. This gives the game a more unique feature and make it more interesting to play.
The limited player vision uses vignette effect which appears on the screen whenever it is triggered. The trigger uses Collider2D which when collided with the player, calls the OnTriggerEnter2D() function. This function then checks if it is of a LimitedVision tag which then calls TriggerLimitedVision() function if true.
Depending on the duration set, the vignette effect will be set active, waits for the desired duration, then set to inactive.

Vignette effect code
Level Advance

Upon touching the level exit, a coroutine is started and the player is brought to the next level after a delay. This is done by incrementing the build index of the scene.
 
Level Exit Script 

Enemy Boss


Boss Animator Controller
Utilizing animator controllers and behaviour scripts, the boss transitions into its phase 1 introduction animation upon entering the level. Following that, using the behaviour scripts, the boss randomly enters one of 2 states, Idle or Jumping. The boss will then transition between these 2 states, staying in each state for a random amount of time that is between the maximum and minimum times set. When the boss goes under half its health,this triggers the animation for its phase 2, where it then randomly transitions between the phase 2 Idle and Jump states. The jump speed and movement speed of the boss are increased in phase 2. Upon reaching 0 health, the boss dies and triggers its death animation.

State
Behavior
Phase 1 Introduction
Plays boss intro animation upon loading of level, then transition to either phase 1 idle or phase 1 jumping.
Phase 1 Idle
The boss stops at the spot for a random amount of time between a set minimum and maximum time, before transitioning to the jumping state.
Phase 1 Jump
The boss moves towards the player while jumping, players are able to dodge under the boss while it is in the air. The boss will transition to the idle state after a random amount of time between a set minimum and maximum.
Phase 2 Introduction
Triggers upon the boss going under half health, and then acts similarly to phase 1 introduction.
Phase 2 Idle
Same as phase 1 idle.
Phase 2 Jump
Same as phase 1 jump but with increased movement and jump speed.
Death 
Triggers upon the boss reaching 0 health, plays boss’ death animation.


Animation


Background Sprites



Warrior Character, Health and Character Sprites


Archer Character Sprites

Boss Character and Health Bar Sprites

These are the animations that we used in our game. These were self designed, and animated frame by frame with the use of Aseprite, an animated sprite editor and pixel art tool.

Animation window for boss enemy
For the boss animations, we had to edit the animation in unity to account for its jumping, and thus offset its collider as well as the position of the sprite.



Problems Encountered
Throughout our development phase, we faced several challenges primarily due to our inexperience with game development and using Unity. This initial learning curve slowed our progress as we had to familiarize ourselves with the tools and practices essential for effective game development. However, our determination to learn and use Unity effectively led us to watch numerous tutorials and complete online courses, allowing us to catch up on what we were lacking and ultimately create a usable product that met our project objectives.

Health UI System Issue:
One specific issue we encountered was with our health UI system. We struggled to correctly link the number of player lives to the health UI displayed on the game screen. For example, when the player died, the health UI incorrectly showed zero lives left, even though the player still had two lives remaining. After extensive code analysis, we identified that the error stemmed from our script being linked to an incorrect folder, causing interference with other scripts. By relocating the script to a separate folder, we resolved this issue and ensured the health UI accurately reflected the player's lives.

Score and Health UI Reset Issue:
Another significant issue was that our score and health UI did not reset upon clicking the main menu button. This created a loophole where players could return to the main menu, restart the game, and re-collect coins to inflate their score. Despite our efforts to fix this bug by repeatedly reviewing our code, we were initially unsuccessful. We decided to temporarily set this problem aside and focus on other deliverables, which provided us with a fresh perspective when we revisited the issue. Ultimately, we were able to modify our code so that the score and health reset to zero when the main menu was clicked, effectively closing the loophole. This experience taught us the value of taking breaks and approaching problems with a renewed mindset, which often leads to more effective solutions.

Persisting Coins Across Scenes Issue:
We also faced issues with our collectibles, particularly with coins not persisting across scenes. When transitioning from Scene 1 to Scene 2, the coins collected in Scene 1 would not carry over to Scene 2. This inconsistency disrupted the game flow and player experience. We learned that implementing a proper game session management system to save and load game progress, including the state of collected items, was crucial. After several iterations, we were able to ensure that collected coins persisted across scenes, enhancing the continuity of gameplay.

Player Lives Resetting on Continue Issue:
Another problem was the constant resetting of player lives to three whenever the game was continued after being paused or when navigating to the main menu. This issue arose from the GameSession script not being correctly attached to the PauseMenu script, leading to the player lives resetting regardless of their actual value. By ensuring that the GameSession script was properly referenced and maintained across game sessions, we were able to fix this issue and maintain the correct number of player lives upon continuing the game.

Enemy Spawning Consistency Issue:
We encountered difficulties ensuring that enemies spawned at the same locations when continuing the game after returning to the main menu. This was important for maintaining consistent gameplay and difficulty levels. By improving our save and load functionality, we managed to preserve the state of enemy positions and ensure that they respawned at the correct locations, providing a more consistent and predictable game experience.

UI Layering and Vignette Effect Issue:
Integrating UI elements with visual effects, such as the vignette effect, posed a challenge. The vignette effect was interfering with the UI layering, causing visual inconsistencies. We had to adjust the UI layering settings and carefully manage the interaction between UI components and visual effects to achieve the desired aesthetic without compromising functionality.

In summary, our challenges primarily stemmed from a steep learning curve with Unity, but our perseverance and strategic problem-solving allowed us to overcome these hurdles and achieve our project goals.


User Feedback
We sought feedback from friends and family members, who are university students and our target audience. Their feedback was generally positive, with suggestions for minor adjustments to enhance the user experience.

Changes Based on Feedback
Character Movement and Jumping Power:
Feedback: Initial character movements were too fast and lacked adequate jumping power, making control difficult.
Change: We slowed down character movements and increased jumping power for better control and user experience.

Multiple Lives:
Feedback: The game was too stressful as it reset upon any player death, allowing no room for mistakes.
Change: We introduced a system where the player has three lives, providing more leeway and reducing stress.

Smoother Character Animations:
Feedback: Character animations were blurry, making the game less user-friendly.
Change: We refined the animations to make them smoother and more natural.

Positive Feedback
Basic Controls and Movements: Users appreciated that the basic controls and movements were well-implemented.
Unique Character Art Design: The distinct character designs were well-received.
Collectible Coins: The feature of collecting coins to gain score was positively noted.
Multiple Levels: Having multiple levels added depth to the gameplay and was appreciated by users.
Overall, our perseverance and willingness to learn allowed us to overcome various challenges and refine our game based on user feedback, resulting in a more polished and enjoyable product.


System Testing

We conducted system testing to ensure the features implemented functions as expected. The table below shows our test cases and the results of each test case.

S/N
Test Case
Results
1
Start the game
Main Menu launched
2
Click on ‘Options’ button
Options Menu appears with a close button
3
Click on ‘Close’ button for the Options Menu
Options Menu closes
4
Click on ‘Quit’ button
Nothing happens
Expected: Blank webpage opens
5
Click on ‘Play’ button
Game loads to Level 1 Scene
6
Click on ‘A’, ‘D’ keys
Character move left and right respectively
7
Click on ‘Spacebar’ keys
Character jumps
8
Click on Left mouse button
Character fires a bullet
9
Click on ‘Esc’ key / Pause button
Pause Menu appears, game freezes
10
Click on ‘Main Menu’ button
Main Menu launched, Game scene resets
11
Click on ‘Quit’ button
Nothing happens
Expected: Blank webpage opens
12
Click on ‘Resume’ button
Game unfreeze, pause menu disappears
13
Falls on spikes
Character resets to starting position, one live removed from health UI
14
Collides with enemies
Character resets to starting position, one live removed from health UI
15
Character jumps to next block
No stick, character manages to land on next block without double jumping
16
Character loses all lives
Character resets to starting position of previous level, resets back to three lives
17
Character collects coins
Coins disappear, SFX triggered, score UI shows an increase in score value
18
Character reaches exit sign
Character teleports to next level


Unit Testing
Lastly, we have included unit testing for our game. This allows us to check the important aspects of our game without physically testing them ourselves. These include information on collectible, enemy, player health and whether save and load games are functioning.

Passing all Unit Testing
An example of our unit testing script looks like this.

Player Health Test Script
Credits
Assets from levels 1 and 2 are accredited to the Super Platformer Assets created by Foxfin and available on the Unity Asset store - https://assetstore.unity.com/packages/2d/environments/super-platformer-assets-42013. 

License Details:
These assets are provided as part of GameDev.tv's Complete Unity Developer 2D course and a part of the Super Platformer Assets created by Foxfin and available on the Unity Asset store - https://assetstore.unity.com/packages/2d/environments/super-platformer-assets-42013.
You are permitted to use these with a personal license which means you can use them for your student project and for learning but you CANNOT use them in a published game. To use these assets in a published game you will need to purchase the asset pack from the asset store - https://assetstore.unity.com/packages/2d/environments/super-platformer-assets-42013

